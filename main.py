from langgraph.graph import StateGraph, END, START
from langchain_experimental.utilities import PythonREPL
from langchain_core.tools import tool
from pydantic import BaseModel
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage

from dotenv import load_dotenv
from typing import List

load_dotenv()
_repl = PythonREPL()

SYSTEM_PROMPT = """
You are an assistant that writes **only** executable Python code, with no extra text or commentary.
Use the `diagrams` package (https://diagrams.mingrammer.com/) to produce an
architecture diagram.  The code **must** save the diagram to a file called
`architecture_diagram.png` in the working directory.

**Constraints**

1. Return only valid Python source code.
2. Do **not** wrap the code in markdown fences.
"""

@tool
def python_repl(code: str) -> str:
    """
    Execute Python in a sandboxed REPL and return standard output.
    """
    try:
        return _repl.run(code)
    except BaseException as e:          # propagate errors as text
        return f"❌ {e.__class__.__name__}: {e}"
    
    


class ChatState(BaseModel):
    """Graph memory.

    """
    user_input: str            # the latest user message

    history:   List[str] = []  # every assistant reply so far


def generate_response(state: ChatState) -> ChatState:
    """
    This node gets the user input, generates a response, and appends it to the history.
    The response is generated by an LLM.
    """
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
    messages = [
        SystemMessage(content=SYSTEM_PROMPT),
        HumanMessage(content=state.user_input),
    ]
    python_code = llm(messages).content.strip()

    state.history.append(python_code)

    return state


def echo_node(state: ChatState) -> ChatState:
    """
    Executes the code in the last message and returns the result.
    """
    
    # Return a *partial* update – LangGraph will merge it with the old state
    reply = python_repl(state.history[-1])
    return state

builder = StateGraph(ChatState)

# Add the single node
builder.add_node("echo", echo_node)
builder.add_node("generate_response", generate_response)

# Route: start → echo → END
builder.set_entry_point("generate_response")
builder.add_edge("generate_response", "echo")
builder.add_edge("echo", END)

graph = builder.compile()
state = ChatState(user_input="""
Generate a diagram of a simple web application architecture with the following components:
- A web server
- A database
- A load balancer
- A cache
The web server should be connected to the load balancer, which is connected to the database and cache.
The diagram should be saved to a file called `architecture_diagram.png` in the working directory.
Use EC2 instances for the web server and database, and an S3 bucket for the cache.
The diagram should be in PNG format.
""", history=list())

state = graph.invoke(state)

print(state)

